(* This file is part of ppx_cstubs (https://github.com/fdopen/ppx_cstubs)
 * Copyright (c) 2018-2019 fdopen
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)

open Migrate_parsetree (* to avoid warnings generated by ppx_tools_versioned *)

type 'a return = {return : 'b. 'a -> 'b}

let with_return (type a) f =
  let module E = struct
    exception E of a
  end in
  try f {return = (fun x -> raise_notrace (E.E x))} with E.E r -> r

let finally ~h f = CCFun.finally ~h ~f

external identity : 'a -> 'a = "%identity"

module Util = struct
  open Mparsetree.Ast_cur

  let with_loc loc f =
    let old_loc = !Ast_helper.default_loc in
    Ast_helper.default_loc := loc ;
    finally ~h:(fun () -> Ast_helper.default_loc := old_loc) f

  let error ?(loc = !Ast_helper.default_loc) fmt =
    Format.ksprintf
      (fun s -> raise (Location.Error (Location.error ~loc s)))
      fmt

  let error_exn ?(loc = !Ast_helper.default_loc) fmt =
    Format.ksprintf (fun s -> Location.Error (Location.error ~loc s)) fmt

  let str_expr ?loc s = Ast_helper.(Exp.constant ?loc (Const.string s))

  let int_expr ?loc ?attrs i =
    Ast_helper.(Exp.constant ?loc ?attrs (Const.int i))

  let mk_loc s = Location.mkloc s !Ast_helper.default_loc

  let mk_lid ?(loc = !Ast_helper.default_loc) s =
    Location.mkloc (Longident.parse s) loc

  let mk_pat s = Ast_helper.Pat.var (mk_loc s)

  let mk_typc ?attrs ?(l = []) s = Ast_helper.Typ.constr ?attrs (mk_lid s) l

  let mk_ident n = Ast_helper.Exp.ident (mk_lid n)

  let safe_ascii c =
    (c >= 'a' && c <= 'z')
    || (c >= 'A' && c <= 'Z')
    || c = '_'
    || (c >= '0' && c <= '9')

  let safe_ascii_only s =
    CCString.filter_map (fun c -> if safe_ascii c then Some c else None) s

  let safe_ascii_only_ml s =
    CCString.filter_map
      (fun c -> if safe_ascii c || c = '\'' then Some c else None)
      s

  let unsuffixed_file_name () =
    let module Lo = Location in
    let module Le = Lexing in
    let loc = !Ast_helper.default_loc in
    let name = Filename.basename loc.Lo.loc_start.Le.pos_fname in
    match CCString.split_on_char '.' name with
    | [] -> ""
    | s :: _ -> safe_ascii_only s

  let safe_cname =
    let i = ref (-1) in
    fun ~prefix ->
      let module Lo = Location in
      let module Le = Lexing in
      let loc = !Ast_helper.default_loc in
      let name = unsuffixed_file_name () in
      let s = safe_ascii_only prefix in
      let cutmax s maxlen =
        let len = String.length s in
        if len > maxlen then String.sub s 0 maxlen else s
      in
      (* TODO: there seems to be a limit for msvc *)
      let s = cutmax s 20 in
      let name = cutmax name 40 in
      incr i ;
      Printf.sprintf "ppxc%x_%s_%x_%x_%s" !i name loc.Lo.loc_start.Le.pos_lnum
        loc.Lo.loc_start.Le.pos_cnum s

  let safe_mlname =
    let i = ref (-1) in
    fun ?(capitalize = false) ?(nowarn = false) ?prefix () ->
      let s, p =
        match prefix with
        | None -> ("", "")
        | Some s -> (safe_ascii_only_ml s, "_")
      in
      let loc = !Ast_helper.default_loc in
      let line = loc.Location.loc_start.Lexing.pos_lnum in
      incr i ;
      let nowarn = if nowarn then "_" else "" in
      let f = if capitalize then 'P' else 'p' in
      Printf.sprintf "%s%cpxc__%s%sline%d_%d" nowarn f s p line !i

  let empty_stri () =
    let vb =
      Ast_helper.Vb.mk ~attrs:[Attributes.remove_attrib] (mk_pat "()")
        (Ast_helper.Exp.ident (mk_lid "()"))
    in
    Ast_helper.Str.value Asttypes.Nonrecursive [vb]

  let marshal_to_str_expr a = str_expr (Marshal.to_string a [])

  let ocaml_warning s =
    let x = mk_loc "ocaml.warning" in
    let pl = Parsetree.PStr [[%stri [%e str_expr s]]] in
    Ast_helper.Attr.mk x pl

  let no_warn_unused_pre406 =
    let open Ast_helper in
    fun stri ->
      if Ocaml_config.version () >= (4, 6, 0) then stri
      else
        let loc = stri.Parsetree.pstr_loc in
        let a = Str.attribute ~loc (ocaml_warning "-32") in
        let mod' = Mod.structure [a; stri] in
        Str.include_ (Incl.mk ~loc mod')

  let no_warn_unused_post406 =
    let open Ast_helper in
    fun name expr ->
      let pat = Pat.var (mk_loc name) in
      let attrs =
        if Ocaml_config.version () < (4, 6, 0) then []
        else [ocaml_warning "-32"]
      in
      let vb = Vb.mk ~attrs pat expr in
      Str.value Asttypes.Nonrecursive [vb]

  let no_warn_unused name expr =
    no_warn_unused_post406 name expr |> no_warn_unused_pre406

  let cloc_comment loc =
    let b = Buffer.create 128 in
    let fmt = Format.formatter_of_buffer b in
    Location.print_loc fmt loc ;
    Format.pp_print_flush fmt () ;
    let s =
      Buffer.contents b
      |> CCString.replace ~which:`All ~sub:"/*" ~by:"/ *"
      |> CCString.replace ~which:`All ~sub:"*/" ~by:"* /"
    in
    String.concat " " ["/*"; s; "*/"]

  let sig_from_mod_type =
    let open Parsetree in
    fun s ->
      match s.pstr_desc with
      | Pstr_modtype {pmtd_type = Some {pmty_desc = Pmty_signature s; _}; _} ->
        s
      | _ -> assert false
end

module Result = struct
  type ('a, 'b) result = ('a, 'b) CCResult.t =
    | Ok of 'a
    | Error of 'b
end

module Various = struct
  let use_threads () =
    let pkgs =
      match Findlib.package_deep_ancestors ["byte"] !Options.findlib_pkgs with
      | exception Fl_package_base.No_such_package _ -> !Options.findlib_pkgs
      | d -> d
    in
    List.exists
      (function "threads" | "threads.posix" -> true | _ -> false)
      pkgs
end
